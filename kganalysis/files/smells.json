[{
  "name": "Cyclic Dependency",
  "aliases": [
    ""
  ],
  "description": "This smell arises when two or more abstractions depend on each other directly or indirectly (creating a tight coupling between the abstractions). A cyclic chain of calls between abstractions exists.",
  "context": "Derived from: \"Cyclic Dependency\"<br /> A special form of Cyclic Dependency is sometimes exhibited with specializations. A subtype has an obvious dependency on its supertype. However, when the supertype also depends on the subtype (for instance, by having an explicit reference to the subtype), it results in a cyclic dependency.",
  "detection": "Abstractions depend on each other in a cyclic interaction pattern, e.g. A depends on B, B depends on C, and C depends back on A. So check all reachable elements for the original element to detect cycles.",
  "consequences": "Abstractions involved in a cyclic dependency can be harder to maintain or reuse, as they are more strongly coupled.",
  "cause": "Hard to visualize indirect dependencies.",
  "solution": "Resolve the cycles by e.g. relocating functionality (merging) or use an intermediary element.",
  "example": "A depends on B, B on C and C on A",
  "sources": [],
  "tags": [
    "soa",
    "microservices",
    "business",
    "application",
    "technology",
    "The Couplers",
    "between elements",
    "automatic detection"
  ],
  "relatedItems": [
    {
      "relation": "relates",
      "name": "Chatty Service"
    },
    {
      "relation": "relates",
      "name": "Nanoservices"
    },
    {
      "relation": "relates",
      "name": "Message Chain"
    }
  ],
  "relatedAntiPatterns": [
    {
      "relation": "relates",
      "name": "Chatty Service",
      "description": "A high number of operations is required to complete one abstraction. Such operations are typically rather simple tasks that needlessly slow down an entire process."
    },
    {
      "relation": "relates",
      "name": "Message Chain",
      "description": "A chain of service calls and messages fulfills common functionality."
    },
    {
      "relation": "relates",
      "name": "Nanoservices",
      "description": "A service is too fine-grained so that its communication and maintenance efforts outweigh its utility. Such services often require several other coupled services to complete an abstraction."
    }
  ],
  "evidence": 0
},
{
  "name": "Dead Component",
  "aliases": [
    "Boat Anchor"
  ],
  "description": "A component is no longer used (usually because it is now obsolete). Or you have generic or abstract elements that are not actually needed today. Such components often exists to support future behavior, which may or may not be necessary in the future.",
  "context": "Derived from: \"Dead Code\"<br /> \"I don't know what that component is used for; it existed before I got here.\" If you are working on a framework, it is eminently reasonable to create functionality not used in the framework itself, as long as the functionality is needed by the users.",
  "detection": "Search for isolated elements: The element respectively its cluster has no incoming or outgoing relations to other components (structural relations can be neglected).",
  "consequences": "Unused elements increase the complexity which harms the readability and maintainability.",
  "cause": "When requirements have changed or corrections have been made, nobody had time to clean up the old structure. Sometimes components are created \"just in case\" to support anticipated future features that never get implemented.",
  "solution": "Delete unused elements. Redistribute the functionality and aggregate components.",
  "example": "A policy or programmatic relationship may require the purchase and usage of a particular piece of hardware or software. The consequences for managers and developers are that significant effort may have to be devoted to making the product work. After a significant investment of time and resources, the staff realizes that the product is useless in the current context, and abandons it for another approach. Eventually, the Boat Anchor is set aside and gathers dust in some corner (if it's hardware).",
  "sources": [],
  "tags": [
    "business",
    "application",
    "technology",
    "The Dispensables",
    "within elements",
    "automatic detection"
  ],
  "relatedItems": [
    {
      "relation": "follows",
      "name": "Lazy Component"
    },
    {
      "relation": "follows",
      "name": "Vendor Lock-In"
    }
  ],
  "evidence": 0,
  "relatedAntiPatterns": [
    {
      "relation": "follows",
      "name": "Lazy Component",
      "description": "A component that is not doing enough to pay for itself should be eliminated. Those components have limited responsibilities. That way, they clutter design, creating unnecessary abstractions. Although delegation is good, and one of the key fundamental features of abstractions, too much of a good thing can lead to objects that add no value, simply passing messages on to another component."
    },
    {
      "relation": "follows",
      "name": "Vendor Lock-In",
      "description": "The usage of diverse proprietary technology leads to many potentially conflicting standards and additional complexity in a system. Often combined with a Wolf Ticket, which is a product that claims openness and conformance to standards that have no enforceable meaning."
    }
  ]
}]